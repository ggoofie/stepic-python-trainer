"""

Суть задачи та же, что и Caesar cipher, с одним отличием: кодируются символы из интервала 1F600—1F64F таблицы символов Юникода. Используется кодировка UTF-8.

Для всех символов сдвиг один и тот же. Сдвиг циклический, т.е. если к последнему символу алфавита применить единичный сдвиг, то он заменится на первый символ, и наоборот.

Напишите программу, которая шифрует текст шифром Цезаря.

Формат ввода:
На первой строке указывается используемый сдвиг шифрования: целое число. Положительное число соответствует сдвигу вправо. На второй строке указывается непустая фраза для шифрования. 

Не обращайте внимания, если у вас отображаются прямоугольники вместо некоторых символов. Это значит, что ваш шрифт не содержит этих символов. Для решения задачи это не имеет никакого значения.

Формат вывода:
Единственная строка, в которой записана фраза: Result: "..." , где вместо многоточия внутри кавычек записана зашифрованная последовательность.

Sample Input 1:

1
😀🙏😇
Sample Output 1:

Result: "😁😀😈"
Sample Input 2:

1
😀😁😂😃😄😅😆😇😈😉😊😋😌😍😎😏😐😑😒😓😔😕😖😗😘😙😚😛😜😝😞😟😠😡😢😣😤😥😦😧😨😩😪😫😬😭😮😯😰😱😲😳😴😵😶😷😸😹😺😻😼😽😾😿🙀🙁🙂🙃🙄🙅🙆🙇🙈🙉🙊🙋🙌🙍🙎🙏
Sample Output 2:

Result: "😁😂😃😄😅😆😇😈😉😊😋😌😍😎😏😐😑😒😓😔😕😖😗😘😙😚😛😜😝😞😟😠😡😢😣😤😥😦😧😨😩😪😫😬😭😮😯😰😱😲😳😴😵😶😷😸😹😺😻😼😽😾😿🙀🙁🙂🙃🙄🙅🙆🙇🙈🙉🙊🙋🙌🙍🙎🙏😀"
"""

import sys


def caesar_cipher(d, fraze):
    # s = ' abcdefghijklmnopqrstuvwxyz'
    s = ''.join([chr(x) for x in range(0x1F600, 0x1F64F+1)])
    alphabet = {s[index]: index for index in range(len(s))}
    result = ''
    length = len(alphabet)
    for symbol in fraze:
        result += s[(alphabet[symbol] + d) % length]
    return result


def main():
    reader = (line for line in sys.stdin)
    d, fraze = int(next(reader)), next(reader).strip()
    print('Result: \"%s\"' % caesar_cipher(d, fraze))


if __name__ == '__main__':
    main()
    
